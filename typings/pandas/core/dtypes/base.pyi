"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Any, Generator, List, Optional, Sequence, Tuple, Type, TypeVar, Union
from typing_extensions import Literal
from numpy import _ScalarLike

"""
This type stub file was generated by pyright.
"""
_ArrayLike = TypeVar("_ArrayLike", _ExtensionArray, np.ndarray)
_DtypeObj = Union[np.dtype, ExtensionDtype]

class ExtensionDtype:
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: Any) -> bool: ...
    @property
    def na_value(self) -> object: ...
    @property
    def type(self) -> Type: ...
    @property
    def kind(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def names(self) -> Optional[List[str]]: ...
    @classmethod
    def construct_array_type(cls) -> Type[_ExtensionArray]: ...
    @classmethod
    def construct_from_string(cls, string: str) -> ExtensionDtype: ...
    @classmethod
    def is_dtype(cls, dtype: object) -> bool: ...

class _ExtensionArray:
    def __getitem__(self, item: Union[int, slice, np.ndarray]) -> Any: ...
    def __setitem__(self, key: Union[int, slice, np.ndarray], value: Any) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Generator[Any, None, None]: ...
    def __eq__(self, other: Any) -> _ArrayLike: ...
    def __ne__(self, other: Any) -> _ArrayLike: ...
    def to_numpy(
        self,
        dtype: Optional[_DtypeObj] = ...,
        copy: bool = ...,
        na_value: Optional[Any] = ...,
    ) -> np.ndarray: ...
    @property
    def dtype(self) -> _DtypeObj: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def size(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    def astype(self, dtype: Union[str, _DtypeObj], copy: bool = ...) -> np.ndarray: ...
    def isna(self) -> _ArrayLike: ...
    def argsort(
        self, ascending: bool = ..., kind: str = ..., *args: Any, **kwargs: Any
    ) -> np.ndarray: ...
    def argmin(self) -> int: ...
    def argmax(self) -> int: ...
    def fillna(
        self,
        value: Union[_ScalarLike, _ArrayLike] = ...,
        method: Optional[Literal["backfill", "bfill", "pad", "ffill"]] = ...,
        limit: Optional[int] = ...,
    ) -> _ExtensionArray: ...
    def dropna(self) -> _ExtensionArray: ...
    def shift(
        self, periods: int = ..., fill_value: object = ...
    ) -> _ExtensionArray: ...
    def unique(self) -> _ExtensionArray: ...
    def searchsorted(
        self,
        value: _ArrayLike,
        side: Optional[Literal["left", "right"]] = ...,
        sorter: Optional[_ArrayLike] = ...,
    ) -> np.ndarray: ...
    def equals(self, other: _ExtensionArray) -> bool: ...
    def factorize(
        self, na_sentinel: int = ...
    ) -> Tuple[np.ndarray, _ExtensionArray]: ...
    def repeat(
        self, repeats: Union[int, np.ndarray], axis: Optional[int] = ...
    ) -> _ExtensionArray: ...
    def take(
        self, indices: Sequence[int], allow_fill: bool = ..., fill_value: Any = ...
    ) -> _ExtensionArray: ...
    def copy(self) -> _ExtensionArray: ...
    def view(self, dtype: _DtypeObj = ...) -> _ArrayLike: ...
    def __repr__(self) -> str: ...
    def ravel(
        self, order: Optional[Literal["C", "F", "A", "K"]] = ...
    ) -> _ExtensionArray: ...
    def __hash__(self) -> int: ...
